
(* :Title: Graphics *)

(* :Authors: Hagen Eck, Sepp Kueblbeck *)

(* :Summary:
	This package contains the Paint-routine for drawing Feynman
	diagrams generated by FeynArts`InsertFields` and topologies
	generated by FeynArts`CreateTopologies`.
*)

(* :Context: HighEnergyPhysics`FeynArts`Graphics` *)

(* :Package Version 2.0 *)

(* :Mathematica Version 2.2 *)

(* :History:
	Created Jan. 1994 from the Paint-package of FeynArts 1.0.
*)

(* :Contents:
	Part1: TopologyGraphics - generate graphics primitives.
	Part2: GraphInfo - read topological information.
	Part3: Paint - draw lists of topologies.
	Part4: Shape - edit topologies.
	(search for Part# to find the beginning of a section)
*)

FAPrint[3, "[Graphics.m]"];

Begin["`Graphics`"];

(* 
  :Part1: 
	TopologyGraphics. This procedure should return a graphics object
	for a bare or inserted topology. It tries to find the coordinates
	of the vertices of the topology (GraphPoints), inserts them, and
	looks for Appearances of the 3rd elements of the propagators.
	I.e. Propagator[ v1, v2, f ] -> PropagatorGraphics[ (x1,y1), (x2,y2),
	Appearance[f] ].
*)

Options[ TopologyGraphics ] =
{
  AspectRatio 		-> 1 ,
  AutoShape		-> False,
  FlipProps		-> {},
  GraphFrame 		-> False,
  GraphLabel 		-> Automatic,
  GraphLabelPosition 	-> Automatic,
  PlotRange 		-> {{-.5, 20.5}, {-.5, 20.5}} ,
  ShowGrid 		-> False,
  ShowPointNames	-> False,
  StandardEndpoints 	-> True,
  TopologyDataDir	:> $TopologyDataDir
}

TopologyGraphics::undef =
"cannot find a GraphPoint-function for this topology.";
TopologyGraphics::noapp =
"no Appearance defined for Symbol `1`.";
TopologyGraphics::autoshape =
"AutoShaping topology. This may lead to very poor output.";
TopologyGraphics::noout =
"TopologyGraphics flips a non-Outgoing Propagator!";

TopologyGraphics[ t:Topology[__][__], opts___Rule ] :=
  TopologyGraphics[ Topology@@t, opts, 
		    Sequence@@(Select[Head[t], MatchQ[#, _Rule]&]) ] ;

TopologyGraphics[ Topology[ pr__, Graph[_][ g__ ] ], opts___Rule ] :=
  TopologyGraphics[ Topology[pr]/.{g}, opts ];

TopologyGraphics[ Topology[ pr__, Graph[ g__ ] ], opts___Rule ] :=
  TopologyGraphics[ Topology[pr]/.{g}, opts ];

TopologyGraphics[ Topology[ pr__, in:Insertions[__] ], 
		  n_Integer, opts___Rule ] :=
  TopologyGraphics[ Topology[pr, in[[n]]], opts ];

TopologyGraphics[ t:Topology[__], opts___Rule ] :=
Block[ { thetop, tdatadir, graphinfo, fieldinfo, graphtop, flip,
	 tgopts, pgopts, gralab, gralabpos, grafra, tempshape=False },
      (* canonical order : *)
	thetop = TSort[t] /.{ Propagator[_] -> Propagator} ;
      (* find topology data directory: *)
	tdatadir = 
	 TopologyDataDir /. {opts} /. Options[TopologyGraphics];
	If[ Head[ContextToFilename[tdatadir]] =!= String,
	    Return[$Aborted]
	  ];
      (* read topological information or AutoShape or abort : *)
      If[
	 ( graphinfo = GraphInfo[t, tdatadir] ) === 
            HighEnergyPhysics`FeynArts`$Undefined,
	 If[ AutoShape /.{opts} /. Options[TopologyGraphics] ,
	     Message[ TopologyGraphics::autoshape ];
	     TSSetFirstGraphPoints[BareTopology[t]];
	     tempshape = True;
	     graphinfo = GraphInfo[t, tdatadir] ];
	 If[ graphinfo === HighEnergyPhysics`FeynArts`$Undefined,
	     Message[ TopologyGraphics::undef ]; 
	     Return[$Aborted] 
	   ]
	];
      (* for compatibility with old GraphPoints-conventions: *)
      If[ Length[ graphinfo ] === 2, AppendTo[ graphinfo, {} ] ];
      (* merge GraphInfo and given Options: *)
      tgopts = 
	ActualOptions[ TopologyGraphics, PropagatorGraphics,
		       Sequence@@ Join[{opts}, graphinfo[[3]]] ];
      (* set Endpoints (if not specified) : *)
      If[ FreeQ[ graphinfo[[1]], PropagatorEndpoints ] &&
	  StandardEndpoints/.tgopts,
	 SetStandardEndpoints[BareTopology[t]];
	 graphinfo = GraphInfo[t, tdatadir]
	];
      (* delete Graphpoints-definition if only temporarily set: *)
      If[ tempshape,
	 Global`GraphPoints[BareTopology[t]] = 
            HighEnergyPhysics`FeynArts`$Undefined
	];
      (* spread selfenergies if not specified : *)
      If[ Length[Union[Take[#,2]& /@ thetop]] < Length[thetop],
	 graphinfo = AutoSpread[ thetop, graphinfo ] ]; 
      (* flip back propagators: outgoing fields are treated as incoming
	 anti-fields. if there are different notations for fields and
	 anti-fields, this will result in "wrong" labels. therefore we
	 flip outgoing props back *)
      flip = FlipProps /. tgopts;
      If[ Length[ flip ] > 0,
	  Do[ 
	  (* first we flip the field => Forward<->Backward, anti-label *)
	     thetop = 
	      ReplacePart[thetop, PropFlip[thetop[[flip[[j]]]]], flip[[j]]];
	  (* we also have to change endpoints {a,b}->{b,a} and negate
	     the PropgatorHeight *)
 	      graphinfo[[1]] = 
	       ReplacePart[graphinfo[[1]],
		graphinfo[[1, flip[[j]]]]/.{
		 Rule[PropagatorEndpoints,{a_,b_}]:>
		  Rule[PropagatorEndpoints,{b,a}],
		 Rule[PropagatorHeight,h_]:>
		  Rule[PropagatorHeight,-h] },
		flip[[j]]] ,
	      {j, Length[flip]}
	    ]
	];
      (* the field information : *)
      thetop =  thetop /. Propagator[x_, y_, field_] :>
			 SetAppearance[ Propagator[x, y, field ] ];
      (* append GraphInfo-options for PropagatorGraphics: *)
      graphtop = (PropInfoAppend@@ #)& /@ 
		 Transpose[ { List@@ (thetop /. graphinfo[[2]]),
		              graphinfo[[1]]                     } ];
      (* if there are Vertex[n,0]'s: *)
      graphtop = ( graphtop /. Vertex[n_,0][i_] :> Vertex[n][i] 
                  ) /. graphinfo[[2]];
      (* append given options for PropagatorGraphics *)
      pgopts = Propagator[FilterOptions[PropagatorGraphics, opts]];
      If[ (MemberQ[pgopts, PropagatorScaling->Automatic])||
	  (FreeQ[pgopts, PropagatorScaling]),
	  AppendTo[ pgopts, PropagatorScaling -> 
		    GraphSize[ (#[[2]])& /@ graphinfo[[2]] ] ] ];
      graphtop = Join[#, pgopts]& /@ graphtop;
      (* join all PropagatorGraphics-primitives : *)
      graphtop = Join@@ (graphtop/.Propagator->PropagatorGraphics);
      (* append the grid if necessary : *)
      If[ 
	 ShowGrid/.tgopts/.Options[TopologyGraphics],
	 AppendTo[ graphtop, ShapingGrid ]
	];
      (* pointnames: *)
      If[
	 ShowPointNames/.tgopts/.Options[TopologyGraphics],
	 AppendTo[ graphtop, PointNames[ graphinfo[[2]] ] ]
	];
      grafra = GraphFrame/.tgopts/.Options[TopologyGraphics];
      If[ 
	 grafra =!= False,
	 If[grafra === True,  (* $Default *)
	    AppendTo[ graphtop, { Thickness[.002], 
	     Line[ {{-.4,-.4},{20.4,-.4},{20.4,20.4},{-.4,20.4},{-.4,-.4}}]}],
	    (* this is rather ugly: we use Head "Plus" for the frame style
	       since the Head "List" doesn't survive: *)
	    AppendTo[ graphtop, 
		     Join[ grafra/.{Plus->List,
				  Dashing[n_?NumberQ]:>Dashing[{n}]} , 
			  { Line[ {{-.4,-.4},{20.4,-.4},{20.4,20.4},
				   {-.4,20.4},{-.4,-.4}}]}]]
           ]
	];
      (* set the label: *)
      gralab = GraphLabel/.{opts}/.Options[TopologyGraphics];
      gralabpos = GraphLabelPosition/.{opts}/.Options[TopologyGraphics];
	If[ gralabpos === Automatic,
	    gralabpos = {{ 10, 1.5 }} 
	  ];
      If[ Head[gralab]===ComposedChar, 
	  If[ Head[gralabpos]===ComposedChar,
	      gralabpos = gralabpos[[1]] ];
	  gralab = Insert[ gralab, gralabpos, 2 ]
	];
      If[
	 gralab =!= None,
	 If[ gralab === Automatic,
	     gralab = MakeAutomaticLabel[ t ] 
	   ];
	 If[ StringQ[gralab],
	     gralab = Text[ gralab, gralabpos[[1]] ]
	   ];
	 AppendTo[ graphtop, gralab ]
	];
      Return[
	     Graphics[
	              List@@graphtop, 
	              FilterOptions[Graphics,opts],
	              FilterOptions[Graphics,
				    Sequence@@Options[TopologyGraphics]] 
		     ]
	   ]
     ];

(* flip propagators of Outgoing fields:
*)
PropFlip[ Propagator[i_, o_, fi_ ] ] :=
  Propagator[ o, i, AntiParticle[fi] ];
PropFlip[ Propagator[Outgoing][i_, o_, fi_] ] :=
  Propagator[Outgoing][o, i, AntiParticle[fi]];
PropFlip[ Propagator[any_][i_, o_, fi_] ] :=
( Message[TopologyGraphics::noout ];
  Propagator[any][o, i, AntiParticle[fi]] );

(* auto labeling:
*)
MakeAutomaticLabel[ t_Topology ] = "";

(*
   Besides this we need a number of auxilliary function for some special
   cases.
*)
(* append PropagatorGraphics-information to Propagator 
*)
PropInfoAppend[ Propagator[ points__ ], Null ] := Propagator[points];
PropInfoAppend[ Propagator[ points__ ], {info___} ] := 
	Propagator[points, info];

(* set Appearance incl. check whether defined or not:
   There might be some Index[_] in the expression from Classes without
   class member specification (e.g.
    TheLabel[F[2]]=CC[{"e",Index[Generation]}] and we want the label of
   "F[2]", only). We replace those free indices by ".".
*)
TopologyGraphics::unres =
"unresolved Appearance symbol: `1` (i'll ignore this).";

SetAppearance[ Propagator[ a_, b_, f_ ] ] :=
Block[ { theApp = Appearance[f] },
(*
Print[f,": ",theApp];
*)
  If[ !FreeQ[ theApp, Literal[PropagatorType[f]] ],
       Message[TopologyGraphics::unres, PropagatorType[f]];
       theApp = Select[ theApp, FreeQ[#, PropagatorType]& ]
    ];
  If[ !FreeQ[ theApp, Literal[PropagatorLabel[f]] ],
       Message[TopologyGraphics::unres, PropagatorLabel[f] ];
       theApp = Select[ theApp, FreeQ[#, PropagatorLabel]& ]
    ];
  If[ !FreeQ[ theApp, Literal[PropagatorArrow[f]] ],
       Message[TopologyGraphics::unres, PropagatorArrow[f] ];
       theApp = Select[ theApp, FreeQ[#, PropagatorArrow]& ]
    ];
  If[ ( theApp === {} ) || ( Head[theApp] === Appearance ),
     Message[ TopologyGraphics::noapp, f ];
     theApp =  Propagator[ a, b ],
     theApp =  Propagator[ a, b, Sequence@@ (theApp/.Index[_Symbol]->".") ]
    ];
  Return[theApp]
];

(* This is the grid for Shape (to find coordinates easier):
*)
ShapingGrid =
{ 
  Thickness[0.001],
  Table[ {Line[{{i, 0.}, {i, 20.}}], Line[{{0.,i}, {20., i}}]},
	 {i, 0, 20, 5} ],
  Thickness[0.001],Dashing[{0.003,0.008}],
  Table[ {Line[{{i, 0.}, {i, 20.}}], Line[{{0.,i}, {20., i}}]},
	 {i, 0, 20} ],
  Text[0, {-.5,-.5} ], Text[5, {-.5, 5}], Text[10, {-.5, 10.}],
  Text[15, {-.5, 15.}], Text[20, {-.5, 20.}], Text[5, {5., -.5}],
  Text[10, {10., -.5}], Text[15, {15., -.5}], Text[20, {20., -.5}]
};

(* This is the list of PointNames
*)
PointNames[ vrule_List ] :=
   vrule /. Rule[ Vertex[i_,c___][j_], { x_, y_ } ] :> 
	    Text[ ToString[i]<>
                   If[Length[{c}]>0, ","<>ToString[c] , "" ]<>
                   "/"<>ToString[j], 
                  {x+.5, y+.5} ];

(* Overall size of graph for PropagatorScaling->Automatic 
*)
GraphSize[ point_List ] := Max[point] - Min[point] ;

(* Spread selfenergies if not set : 
*)
AutoSpread[ t_Topology, g_List ] :=
Block[ {pos, pinf = g[[1]]/.Null->{}, info, ttwo = Take[#,2]& /@ t },
  Do[ 
  If[ Length[ pos = Flatten[ Position[ ttwo, ttwo[[i]] ] ] ] > 1,
     info = pinf[[#]]& /@ pos;
     If[ ( FreeQ[ info, PropagatorHeight ] ) &&
	 ( FreeQ[ info, Propagator3rdPoint ] ) ,
      Which[ (Length[pos]===2)||(Length[pos]===3),
	AppendTo[ pinf[[pos[[1]]]], PropagatorHeight->2 ];
	AppendTo[ pinf[[pos[[2]]]], PropagatorHeight->-2 ],
       Length[pos]===4,
	AppendTo[ pinf[[pos[[1]]]], PropagatorHeight->2];
	AppendTo[ pinf[[pos[[2]]]], PropagatorHeight->-2 ];
	AppendTo[ pinf[[pos[[3]]]], PropagatorHeight->1];
	AppendTo[ pinf[[pos[[4]]]], PropagatorHeight->-1 ],
      True,
	Print["Problems with AutoSpread (no spread)."] ]
      ]
    ],
   {i,Length[ttwo]}
  ];
  Return[ {pinf/.{}->Null,g[[2]]} ];
];

(* 
  :Part2:
	GraphInfo: Graphics information and file handling.
	GraphInfo[t] returns the value of Global`GraphPoints[t] if possible.
*)

(* only the topological information needed for GraphInfo:
*)
BareTopology[ Topology[_][p__] ] := BareTopology[ Topology[p] ];
BareTopology[ t_Topology ] := 
     Take[#, 2]& /@ TSort[ t /. Vertex[n_,0][i_] :> Vertex[n][i] ];

(* The function to determine the file name for GraphPoints functions. 
   We just count the number of Loop[_]-propagators that were present in 
   the starting topology and the number of incoming and outgoing particles. 
   We have to prepend a letter ("t") since otherwise Mathematica can't 
   parse the Context.
*)
GraphTypeFunction[ t_Topology ] :=
  If[ FreeQ[ t, External ],
     "t" <>
     ToString[Length[Union[Cases[t, Propagator[Loop[n_]][__]->n]]]] <>
     ToString[PropagatorCount[Incoming][t]] <>
     ToString[PropagatorCount[Outgoing][t]] ,
     "t" <>
     ToString[Length[Union[Cases[t, Propagator[Loop[n_]][__]->n]]]] <>
     ToString[PropagatorCount[External][t]]
    ];
  
(* the function GraphInfo loads automatically the definitions for
   a special type of topologies. the definitions for the other types
   are removed (with Clear). the variable $GraphType holds the 
  loaded type, $TDataDir the actual topology data directory.
*)
If[ !ValueQ[$GraphType], $GraphType = None] ;
If[ !ValueQ[$GraphDir], $TDataDir = $TopologyDataDir] ;

(* default for GraphPoints: 
*)
Global`GraphPoints[_Topology] := HighEnergyPhysics`FeynArts`$Undefined;

(* GraphInfo function:
*)
GraphInfo[ Topology[_][p__], opt___] := GraphInfo[Topology[p], opt];

GraphInfo[ t_Topology, dir_String ] :=
 Block[{baretop, graphtype, graphfile, gp },
       baretop = BareTopology[ t ];
       graphtype = GraphTypeFunction[ baretop ];
       graphfile = dir <> graphtype <> "`";
       If[ ($GraphType===graphtype) && ($TDataDir===$TopologyDataDir) ,
	  (* then: *)
	  gp =  Global`GraphPoints[baretop], 
          (* else: *)
	  Clear[ Global`GraphPoints ];
	  $GraphType = graphtype;
	  $TDataDir = $TopologyDataDir;
	  SetDelayed[ Global`GraphPoints[_Topology], 
                         HighEnergyPhysics`FeynArts`$Undefined];
	  If[ Get[graphfile] === $Failed,
              Return[ HighEnergyPhysics`FeynArts`$Undefined ] 
	    ];
	  gp = Global`GraphPoints[baretop]; 
	];
       Return[gp]
     ];

(*
  :Part3:
	Paint.
	Main function for drawing topologies or Feynman graphs created by 
   	FeynArts. Paint deals with objects of Head TopologyList containing
  	pure or inserted topologies. Since we also have to accept 
   	InsertFields-output we have to bring it in a suitable form.
   	This part of Paint follows the conventions of InsertFields and
   	can be called with Paint[ lev ][ arguments ] where level is one or
   	a list of the symbols Generic, Classes, Particles and All.
  	Paint for Insertfields-output defaults to Paint[Particles].
*)

(* An empty place for Paint: 
*)
TopologyGraphics[ text_String, any___Rule ] = Graphics[
 {PointSize[ 0.000001 ],Point[{-.5,-.5}],Point[{20.5,20.5}],
  Text[FontForm[text, {$TextFont,$FontSize}], {10.,10}, {0.,0.} ] }, 
 PlotRange->{{-.5,-.5},{20.5,20.5}},
 AspectRatio->1 ];

(* better NumberQ:
*)
numberQ[ x_ ] := NumberQ[N[x]];

(* We should never have to construct our own label in the Paint-procedure.
   If we have to, this function could do this work. At the moment I just
   keep it but I think we don't need it.
*)
MakeAutomaticLabel[ t_Topology ] :=  "";

Options[ Paint ] =
{
   AutoShape	  -> False,
   ColumnsXRows   -> 3,
   Destination 	  -> Screen,
   DisplayMode 	  -> Page,
   DoNotStop 	  -> False,
   FileBaseName	  :> ProcessName,
   FontScaling	  -> True,
   GraphFrame     -> {Generic[True], 
                      Classes[{Thickness[0.002], Dashing[{0.02}]}]},
   GraphLabel 	  :> $DefaultLabel,
   GraphSpacing   -> .5,
   PaintLevel 	  -> Automatic
};

Paint::nolev =
"PaintLevel `1` not present in InsertionList: ignoring.";
Paint::badlev =
"bad level specification : `1`";
Paint::badnum =
"bad graph numbering specification : `1`";
Paint::badopt =
"bad option value for `1`: \"`2`\" is not one of `3`."
Paint::badcxr =
"value for ColumnsXRows (`1`) is not an integer or a pair of integers.";

(* DEFAULT 
*)
$DefaultLabel = ComposedChar[ {ProcessName, {Topology,".",Number}} ];

(* Paint for InsertFields output: the general case.
*)
Paint[ t:TopologyList[ info___Rule ][ tops__], opt___Rule ] :=
Block[ { OPT = ActualOptions[Paint, opt], lab, lev, inslev,
	 mod, genmod, fname, box },
   lev = PaintLevel /. OPT;
   inslev =  GetAllLevels[ InsertionLevel/.{info} ];
   fname = FileBaseName /. OPT /. {info};
   box = GraphFrame/.OPT;
   If[ lev===Automatic, 
	lev=inslev,
	lev=GetAllLevels[lev]
     ];
   If[ FreeQ[ inslev, # ],
       Message[ Paint::nolev, # ];
       Null,
       #
     ]& /@ lev;
   lev = ReleaseHold[ lev /. Null -> Hold[Sequence[]] ];
   lab = GraphLabel /. OPT;
   If[ (genmod = GenericModel/.{info}) === GenericModel,
      genmod = "Lorentz"
     ];
   If[ (mod = Model/.{info}) =!= Model,
      If[ ModelName[mod] =!= ModelName[$Model],
	  FAPrint[3, "$Model : ",$Model];
          Print["The model ", ModelName[mod], " is not initialized!"];
          If[ FreeQ[{"n","N"}, InputString["initialize? (y) "] ],
                InitializeModel[ mod, GenericModel->genmod ] 
            ]
	]
     ];
   Paint[ TopologyList@@ 
	    InsertionsList[ lev ][ TopologyList[info][tops], lab, box ], 
          FileBaseName->fname, opt ]
];

ModelName[s_String] :=s;
ModelName[{s_String,__}] :=s;

GetAllLevels[ l_List ] := l;
GetAllLevels[ l_Symbol ] :=
 Which[ l===Generic, {Generic},
	l===Classes, {Generic, Classes},
	l===Particles, {Generic, Classes, Particles},
	True, {Generic, Classes, Particles} 
      ];
    
(* And hopefully the definition above did it right so we have our
   InsertFields-output changed to a nice TopologyList. So here's the "real" 
   Paint-procedure:
   We assume all information that has to be passed to TopologyGraphics
   (especially the GraphLabel) to be contained in the Heads of the 
   Topologies.
*)
Paint[ t_TopologyList, opt___Rule ] :=
Block[ { OPT = ActualOptions[ Paint, opt ], 
	 gpr, rps, gar, dest, gs, nos, name, head, fname, fontsc,
	 Grarray = t, thesheet, newmemb, allsheets = {}, 
	 xsh, ysh, xmax=0., ymax=0., cat, Old$PS, $PS },
      gar = ColumnsXRows/.OPT;
      gs = GraphSpacing/.OPT;
      dest = Destination/.OPT;
      name = GraphLabel/.OPT;
      fname = FileBaseName/.OPT;
      fontsc = FontScaling/.OPT;
    (* set graphs per row (gpr) and rows per sheet (rps) 
     *)
      Which[ MatchQ[ gar, {_Integer, _Integer} ],
             { gpr, rps } = gar,
             MatchQ[ gar, _Integer ],
             rps = gpr = gar,
             True,
             Message[Paint::badcxr, gar ];
             Return[$Aborted]
           ];
    (* scaling fonts (optional) 
     *)
      If[ fontsc,
	 If[ !ValueQ[Old$FontSize], Old$FontSize = $FontSize ];
	 If[ !ValueQ[Old$SmallFontSize], Old$SmallFontSize = $SmallFontSize ];
	 $FontSize = Round[ N[ 2.2*Old$FontSize / Log[ gpr*rps ] ] ];
	 $SmallFontSize = Round[ N[ 2.2*Old$SmallFontSize / Log[ gpr*rps ] ] ]
        ];
    (* scaling endpoints (always)
     *)
      Old$PS = PointSize/.Options[PropagatorGraphics];
      $PS = N[ 2.2*Old$PS / Log[ gpr*rps ] ]; 
    (* checking for label:
     *)
      If[ Length[t[[1,1]]] === 2,   (* topologies! *)
	  If[ (name =!= None) && 
              (!MatchQ[ Head[name], (ComposedChar|String) ]),
              name = ComposedChar[{"T", Number}]
            ];
        ];
      If[ Name===None,    (* "delete" GraphLabels *)
         Do[
            head = Head[Grarray[[i]]];
            If[ !FreeQ[head, GraphLabel],
               head = head /.Rule[GraphLabel,_]:>Rule[GraphLabel,None],
               AppendTo[ head, Rule[ GraphLabel, None ] ]
              ];
            Grarray[[i]] = head@@ Grarray[[i]],
            {i, Length[Grarray]}
           ],
         (* else name =!= None *)
          Do[
             If[ FreeQ[ Head[t[[i]]], GraphLabel ],
                 Grarray[[i]] = 
                   Topology[ GraphLabel -> 
                                 (name /. ProcessName -> 
                                    "" /. Number->ToString[i] /.
                                    Topology -> ToString[i]
                                 )
                           ] @@ Grarray[[i]]
                ],
              {i, Length[Grarray]}
             ]
         ];
    (* output file handling:
     *)
      If[ dest === All, dest = {File,Screen} ];
      If[ !FreeQ[ {dest}, File ],
          If[ !FreeQ[ fname, ProcessName ],
             fname = fname/.ProcessName->"noname"
            ];
	 If[ (DisplayMode/.OPT) === All,
	    Off[DeleteFile::nffil];
	    If[ DeleteFile[ fname<>".mps" ] === $Failed,
		Print["write to file \"",fname,".mps\""],
		Print["overwrite file \"",fname,".mps\""]
	      ];
	    On[DeleteFile::nffil];
	    OpenAppend[fname<>".mps"]
	   ]
	];
      (* number of sheets: *)
	nos = Ceiling[ Length[t] / (gpr rps) ];
	FAPrint[1,"Generating ",nos," sheet", If[nos>1,"s",""],
		  " of graphics."];
      (* loop over sheets: *)
      If[ Catch[
      Do[ 
	 If[nos>1, FAPrint[1,"generating sheet #",i]];
	 thesheet = If[ i < nos, Take[ Grarray, (gpr*rps) ], Grarray ];
	 If[ i < nos, Grarray = Drop[ Grarray, gpr*rps ] ];
	 If[ (i == nos) && (Length[thesheet] < (gpr*rps)),
	     While[ Length[thesheet] < (gpr*rps), AppendTo[ thesheet, "" ]]
	   ];
	 thesheet = Partition[ List@@thesheet, gpr ]; 
	(* loop over one sheet: *)
         Do[
            FAPrint[2, "generating sheet #",i," row #",j];
	(* loop over one row: *)
	    Do[
               FAPrint[2, "generating sheet #",i," row #",j," graph #",k];
	     (* computing x- and y-shift: *)
	       xsh = (21+gs)*(k-1); If[xsh>xmax, xmax=xsh];
	       ysh = (21+gs)*(rps-j); If[ysh>ymax, ymax=ysh];
	       If[( newmemb = TopologyGraphics[thesheet[[j,k]],PointSize->$PS]
		  ) === $Aborted,
		  Which[
			AutoShape/.OPT,
			thesheet[[j,k]] = 
			 TopologyGraphics[thesheet[[j,k]], AutoShape->True,
                                          PointSize->$PS ],
		        DoNotStop/.OPT,
		        thesheet[[j,k]] = 
			 TopologyGraphics[" :-( "],
		        True,
		         Throw[$Aborted]
		       ],
	           thesheet[[j,k]] = newmemb
		  ];
	       If[ thesheet[[j,k]]===$Aborted,
		   Throw[$Aborted]
		  ];
	     (* save single graph: *)
	       If[ (DisplayMode/.OPT) === Graph,
		Display[ToString[fname]<>"_p"<>ToString[i]<>"_g"<>
                        ToString[(j-1)*rps + k]<>".mps",
	                thesheet[[j,k]] ]
	       ];
	     (* shift the graph to right position: *)
	       thesheet[[j,k]] = ((thesheet[[j,k]]/.{
		   Circle[{x_,y_},r_,{t1_,t2_}]:>Circle[{x,y},r,list[t1,t2]],
		   Dashing[{x_,y_}]:>Dashing[list[x,y]],
		   Text[a_, b_, {x_,y_}]:>Text[a,b,list[x,y]],
		   ComposedChar[ a_List, { {p1_,p2_}, b___ }] :>
		    ComposedChar[ a, {{p1+xsh,p2+ysh}, b }/.List->list ],
		   ComposedChar[ a_List, { {p1_,p2_}, b___ }, c__ ] :>
		    ComposedChar[ a, {{p1+xsh,p2+ysh}, b }/.List->list,
				  c/.List->list ]}
		   )/.{{x_?numberQ,y_?numberQ}:>{x+xsh,y+ysh}})/.list->List ,
	       {k,1,gpr} 
	      ],
	    {j,1,rps}
	   ];
	 If[ !FreeQ[ {dest}, Screen ],
             Show@@ ( Flatten[ thesheet, 1 ] ) 
	   ];
	 thesheet = thesheet //. 
	     Graphics[{a___},b___Rule] :> Graphics[{a}] ;
	 thesheet = Flatten[thesheet];
         thesheet = Graphics[ thesheet/.Graphics->Identity,
			  AspectRatio->1,
			  PlotRange->{{-.5,xmax+21},{-.5,ymax+21}}];
	 AppendTo[ allsheets, thesheet ];
	 If[ !FreeQ[ {dest}, File ],
	     If[ (DisplayMode/.OPT) === Page,
		 Display[ToString[fname]<>"_p"<>ToString[i]<>".mps", thesheet]
	       ];
             If[ (DisplayMode/.OPT) === All, 
	        Display[ fname<>".mps", thesheet ];
		If[ i =!= nos,
		    WriteString[fname<>".mps", "showpage"];
		    Write[      fname<>".mps"];
		    WriteString[fname<>".mps", "/Mwidth 8.5 72 mul def"];
		    Write[      fname<>".mps"];
		    WriteString[fname<>".mps", "/Mheight 11 72 mul def"];
		    Write[      fname<>".mps"]
		  ]
	       ];
	    ],
	 {i,1,nos}
        ] (* end of loop over sheets, now catch :*)
	 ] === $Aborted,       
	(* $Aborted: *)
	  Return[$Aborted],
	(* else: *)
          If[ (!FreeQ[ {dest}, File ]) && (DisplayMode/.OPT)===All,
	      Close[fname<>".mps"]
	    ];
           Return[ allsheets ]
	]
      ];

(* *)
InsNumber[ s_, i_Integer ] :=
  If[ !FreeQ[ s, Number ],
  (*Print["Return s/N->i"];*)
      s /. Number->i,
      If[ Head[s]===String || Head[s]===SymbolChar,
	(*  Print["Return CC"];*)
	  ComposedChar[ {s, ToString[i]} ],
	 (* Print["Return s"];*)
	  s ]
    ];

(* 
  The following functions are needed for "Paint for InsertFields-output"
  and do all the insertions of fields into the topologies. We also have
  to keep track of the numbering of graphs and of the type of fields in-
  serted (Generic etc.).
  Remember: the graphs are nested Graph[s, n][..] -> constructs where
  s = combinatorial factor and n the number of the graph (Generic==n etc).
*)
$count=0;

InsertionsList[ t:TopologyList[___][___], label_, box_ ] :=
  InsertionsList[Particles][t, label, box];

InsertionsList[All][ t:TopologyList[___][___], label_, box_ ] :=
  InsertionsList[{Generic,Classes,Particles}][t, label, box];

InsertionsList[ spec_ ][ t:TopologyList[inf___][___], label_, box_ ] :=
Block[ {toplist, inslist, s, bottomlevel, name },
	  If[ Head[spec] =!= List, s = {spec}, s = spec ];
	  If[ Complement[ s, {Generic,Classes,Particles} ] =!= {},
	      Message[Paint::badlev, spec];
	      Return[ $Aborted ] ];
        (* the lowest level will get Number-ed *)
          bottomlevel = Last[s];
	(* check process: *)
	  io = Process/.{inf};
	  If[ MatchQ[ io, {__}->{__} ],
	      io = Length[io[[1]]] + Table[i,{i,Length[io[[2]]]}],
	      io = {}
	     ];
        (* separate topology and graphs: 
         *)
          toplist = #[[1]]& /@ t;
          inslist = List@@( #[[2]]& /@ t );
	(* supply every Graph with Topology numbers: 
         *)
          inslist = 
            Array[ (inslist[[#]]//.
                      Graph[s_Integer,n___]:>Graph[Topology==#,n])&,
                   Length[t] ];
	(* make a flat list of graphs with numbers in the Heads (i.e.
           Graph[ Toplogy==n, Generic==m, .... ] ) (insertions: see below)
         *)
          inslist = 
            Flatten[inslist /. Insertions->insertions 
				 /. Rule[Field[a_],x_]:>rule[Field[a],x]
				 /. Rule->List /. rule->Rule];
        (* now we select for the wanted graphs: 
         *)
          If[ FreeQ[ s, Particles], 
              inslist = 
                Select[inslist, FreeQ[#, Particles ]&] ];
          If[ FreeQ[ s, Classes],
              inslist = Select[inslist, 
                        (FreeQ[#,Classes]||(!FreeQ[#,Particles]))&]];
          If[ FreeQ[ s, Generic],
              inslist = Select[inslist, 
                        !(FreeQ[#, Classes]&&FreeQ[#,Particles])&]];
        (* and put them together again:
         *)
          toplist = Head[toplist]@@
           Array[ Prepend[ TopSelect[inslist, #], toplist[[#]] ]&,
                  Length[toplist]
                ];
	(* in Paint we use ProcessName to specify the GraphLabel, so we
	   don't have to take care here: 
         *)
	  name =  ProcessName /. List@@Head[t] ;
	  If[ name===ProcessName || name===Automatic, name = "?" ];
	  If[ Head[name] === Symbol, name = ToString[name] ];
        (* now use the correct label definition for name:
         *)
          name = label /. ProcessName->name;
	(* perform insertion and set correct GraphLabel: 
         *)
          $count = 1;
	  toplist = (Sequence@@ DoInsert[ #, name, bottomlevel, io, box ]
                     )& /@ toplist;
          Return[ toplist ];
        ];

insertions[ type_ ][ r__Rule ] :=  
  Array[ ({r}[[#]] /. Graph[t__,l_]:>gra[t,type==#,l])&, Length[{r}] ];
gra[ all__ ] := Graph@@ Union[{all}];
insertions[ type_ ][ g:Graph[__][__].. ] := {g};

TopSelect[ g_List, n_Integer ] := 
   Select[g, MemberQ[ Head[#], Topology==n ]& ];

(* InsertionsList first constructs a list of the insertions of the form:
   { Topology[ .. ], Graph[ nn ][ .. ] ], Graph[ nn ][ .. ] ], ...}
   with correct numbers in the Head of every Graph. 
   DoInsert performs the real insertion with this list.
*)
DoInsert[ { t:Topology[__], ins___ }, name_, nlev_, io_List, box_ ] :=
Block[ { ret = {}, new, numrules, label, num },
     (* loop over all insertions {ins}:
      *)
      Do[
        (* apply rules to get new graph:
         *) 
	 new = t /. Flatten[ List@@ ({ins}[[i]] /. Graph[_]->List) ];
        (* replace numbering symbols for the label:
         *)
         numrules = List@@ Head[{ins}[[i]]] /. 
                      Equal[lev_,n_Integer]:>Rule[lev,ToString[n]];
         If[ !FreeQ[numrules, nlev],
            num  = $count++;
            AppendTo[ numrules, Number->ToString[num] ]
           ];
         label = name /. numrules /. 
           {Generic->"",Classes->"",Particles->"",Topology->"",Number->""};
         label = label /.{a___,".",""}:>{a} //. 
                         {a___, ".", "", ".", b___}:>{a,".",b};
	(* add a frame arround graph *)
	   Which[
	       IsGeneric[ Head[ {ins}[[i]] ] ],
	       new = Topology[ GraphLabel->label, FlipProps->io, 
			GraphFrame->GetFrame[Generic][box] ]@@ new,
	       IsClasses[ Head[ {ins}[[i]] ] ],
	       new = Topology[ GraphLabel->label, FlipProps->io, 
			GraphFrame->GetFrame[Classes][box] ]@@ new,
	       True,
               new = Topology[ GraphLabel->label, FlipProps->io,
                        GraphFrame->GetFrame[Particles][box] ]@@ new
	     ];
	   AppendTo[ ret, new ],
           { i, Length[ {ins} ] }
	  ];
	 Return[ ret ]
      ];

IsGeneric[ x_ ] := FreeQ[x, Particles]&&FreeQ[x,Classes];
IsClasses[ x_ ] := FreeQ[x, Particles]&&(!FreeQ[x,Classes]);
IsParticles[ x_ ] := !FreeQ[ x, Particles ];
GetFrame[type_][__] = False;
GetFrame[type_][False] = False;
GetFrame[type_][type_[frame_]] := frame;
GetFrame[type_][{___, type_[frame_], ___}] := frame;

(*
  :Part4:
	Shape: A simple editor for topologies for Feynman graphs. This
	procedure set the funtion Global`GraphPoints` for a topology.
*)

Options[ Shape ] :=
  {
   TopologyDataDir :> $TopologyDataDir
  };

Shape[ t:TopologyList[__][___], opt___Rule ] := Shape[ #, opt ]& /@ t;

Shape[ t:TopologyList[___], opt___Rule ] := Shape[ #, opt ]& /@ t;

Shape[ Topology[_][ p__ ], opt___Rule ] := Shape[ Topology[p], opt ];

Shape[ Topology[ p__ ] -> Insertions[__][___] , opt___Rule ]:=
    Shape[ Topology[p], opt ];

Shape[ Topology[ props:Propagator[_][__].. ], opt___Rule ] :=
Module[ { edittop, topopt, command, graphfile, tdatadir, graphtype, 
          justsaved=True, verbose=False, 
          holdFS = $FontSize, holdSFS=$SmallFontSize },
       (* enlarge fonts: *)
        $FontSize = 16;
        $SmallFontSize = 12;
       (* topological information: *)
        edittop = BareTopology[Topology[props]];
       (* read and write to: *)
	tdatadir = TopologyDataDir/.{opt}/.Options[Shape];
        FAPrint[3, "target directory: ", tdatadir];
	graphtype = GraphTypeFunction[ edittop ];
	graphfile = ContextToFilename[tdatadir<>graphtype<>"`"];
       (* graphpoints information : *)
	If[ GraphInfo[edittop, tdatadir] === 
              HighEnergyPhysics`FeynArts`$Undefined,
            Print["undefined topology!"];
            Print["target file: ", graphfile ];
	    TSSetFirstGraphPoints[edittop]           
	  ]; 
       (* enhancement: GraphInfo takes TopologyGraphics-Options;
	  as a third argument. For compatibility we add: *)
       If[ Length[ Global`GraphPoints[edittop] ] === 2,
	   Print["... changing GraphPoints to new conventions."];
	   Global`GraphPoints[edittop] = 
	     Append[Global`GraphPoints[edittop],{}]
	 ];
       (* interactive part : *)
       Print["for help type `?'"];
       command=" ";
       While[ (command!="x") || (command==EndOfFile),
        Which[ command == "s",
	       topopt = Global`GraphPoints[edittop][[3]];
               Show[ TopologyGraphics[ TSAppend[ edittop, StLab ], 
		      Sequence@@topopt,
		      PropagatorThickness->0.005,
		      GraphLabel->ComposedChar[{"label",graphtype}],
		      PointSize->0.020,
		      ShowGrid->True, 
		      ShowPointNames-> True, AspectRatio->1,
		      PlotRange->{{-1.,20.5},{-1,20.5}}] 
		   ],
	       command == "e",
	        TSShapeEndpoints[ edittop ]; justsaved=False,
	       command == "f",
	        TSFileHandling[ edittop, tdatadir ]; justsaved=True,
	       command == "v",
	        TSVertexShift[ edittop ]; justsaved=False;
		If[ verbose, TSPrintPoints[ edittop ] ],
	       command == "h",
	        TSSetHeight[ edittop ]; justsaved=False;
		If[ verbose, TSLongPrintPoints[ edittop ] ],
	       command == "l",
	        TSSetLabelPos[ edittop ]; justsaved=False,
	       command == "d",
	        TSSetDLabelPos[ edittop ]; justsaved=False,
	       command == "L",
	        TSSetGraphLabelPos[edittop]; justsaved=False,
	       command == "?",
	        PrintShapeHelp[] ,
               command == "a",
                TSSetFirstGraphPoints[edittop]; justsaved=False ,
   	       command == "P",
                TSLongPrintPoints[ edittop ],
   	       command == "p",
                TSPrintPoints[ edittop ],
               command == "c",
                TSCenterChoice[ edittop ]; justsaved=False;
		If[ verbose, TSLongPrintPoints[ edittop ] ],
	       command == "u",
                TSGraphShift[ edittop ]; justsaved=False ,
	       command == "z",
	        TSSubMenu[ edittop ]; justsaved=False,
	       command == "t",
		If[ verbose, Print["(info disabled)"]; verbose=False,
			     Print["(info enabled)"]; verbose=True ]
            ];
	command = InputString["\nShape > "] 
       ];
       If[ !justsaved,
	  If[ InputString[
	      "Graphics information not saved ! save ? (y/n) "] == "n" ,
	      Return[],
	      TSFileHandling[ edittop, tdatadir ]
            ]
        ];
      (* reset fonts: *)
       $FontSize = holdFS;
       $SmallFontSize = holdSFS;
     ];

(* utility function : input of a vertex 
*)
InputVertex[top_] := 
   Block[ {i, o, stop=False},
	 While[ !stop,
		i = InputString["Vertex["];
		Which[ StringMatchQ[ i, "*,*" ],
		       o = ToExpression["Vertex["<>i<>"]"];stop=True,
		       IntegerQ[ ToExpression[i] ],
		       o = Vertex[ ToExpression[i] ];stop=True,
		       i === "x", o=$Aborted; stop=True,
		       True,stop=False
		     ]
	      ];
	 If[ o===$Aborted, Return[$Aborted] ];
	 While[ !IntegerQ[ i = Input[ ToString[o]<>"[" ] ] ];
	 o = o@i;
         If[ FreeQ[top, o], 
	    Print[o," : point not present !"]; 
	    o = InputVertex[top] ];
         Return[o] 
	];

(* utility function : set feature of propagator #n 
*)
SetFeature[ top_Topology, f_Rule, n_Integer ] :=
  Block[ { info = Global`GraphPoints[ top ] },
	If[ info[[1,n]] === Null, 
	    info[[1,n]] = {} ];
	If[ (f === Rule[ PropagatorEndpoints, None ]) ||
	    (f === Rule[ PropagatorHeight, 0] ) ||
	    (f[[2]] === Automatic ) ||
	    (f[[2]] === $Default ),
	Print["deleting feature ",f[[1]]];
	    info[[1,n]] = Select[ info[[1,n]], FreeQ[#, f[[1]]]& ],
	    info[[1,n]] = Append[ Select[ info[[1,n]], FreeQ[#, f[[1]]]& ], 
				  f ]
	  ]; 
	If[ f[[1]] === PropagatorHeight,
	    info[[1,n]] = 
	     Select[ info[[1,n]], FreeQ[#, Propagator3rdPoint]& ] ];
	If[ f[[1]] === Propagator3rdPoint,
	    info[[1,n]] = 
	     Select[ info[[1,n]], FreeQ[#, PropagatorHeight]& ] ];
	If[ info[[1,n]] === {},
	    info[[1,n]] = Null ];
        Set[ Global`GraphPoints[ top ], info ]
       ];

(* utility function : set feature of topology
*)
SetTFeature[ top_Topology, f_Rule ] :=
  Block[ { info = Global`GraphPoints[ top ] },
	If[ (f[[2]] === Automatic)||
	    (f[[2]] === $Default),
	Print["deleting feature ",f[[1]]];
	   info[[3]] = Select[ info[[3]], FreeQ[#, f[[1]]]& ],
	   info[[3]] = Append[ Select[ info[[3]], FreeQ[#, f[[1]]]& ],
			       f ]
	  ];
	 Set[ Global`GraphPoints[ top ], info ]
       ];

(* utility function : call feature of propagator #n 
*)
CallFeature[ top_Topology, f_Symbol, n_Integer ] :=
  If[ !FreeQ[ Global`GraphPoints[ top ][[1,n]], f ],
     f /. Flatten[Global`GraphPoints[top][[1,n]]/.Null->{}],
     False ];

(* choose coordinates of a vertex 
*)
TSVertexShift[ t_Topology ] :=
  Block[ { v, info = Global`GraphPoints[t], oldx, oldy, shx, shy },
	v = InputVertex[t];
	If[ v===$Aborted, Return[] ];
        {oldx,oldy} = v/.info[[2]];
	While[ !NumberQ[ shx = Input[ToString[v]<>":Shift x="<>
				     ToString[oldx]<>" by "] ] ];
	While[ !NumberQ[ shy = Input[ToString[v]<>":Shift y="<>
				     ToString[oldy]<>" by "] ] ];
	info[[2]] = Append[ Select[ info[[2]], FreeQ[#, v]& ],
			    v->{oldx+shx, oldy+shy} ];
	Set[ Global`GraphPoints[t], info ];
       ];

(* utility function: choose a propagator
*)
TSReadProp[ max_Integer ] :=
  Block[ { n },
	While[ !IntegerQ[ n = Input["Propagator number ? : "] ] ];
	Which[ n > max ,
	      Print["There are only ",max," Propagators!"];
	      Return[ TSReadProp[max] ],
	       n < 1,
	      Print["You're kidding!"];
	      Return[ TSReadProp[max] ],
	       True,
	      Return[ n ]
	     ];
       ];

(* set PropagatorHeight 
*)
TSSetHeight[ t_Topology ] :=
  Block[ { n = TSReadProp[Length[t]], info = Global`GraphPoints[t], 
	   newh, oldh },
	If[ info[[1,n]] === Null , info[[1,n]] = {} ];
        If[ (oldh=PropagatorHeight/.info[[1,n]]) === PropagatorHeight,
	   oldh = 0 ];
	While[ !NumberQ[ newh=Input["Set Height of #"<>ToString[n]<>
				    " from "<>ToString[oldh]<>" to : "] ] ];
	SetFeature[ t, PropagatorHeight->newh, n ]
       ];
        
(* set PropagatorLabelPosition 
*)
TSSetLabelPos[ t_Topology ] :=
  Block[ { n = TSReadProp[Length[t]], info = Global`GraphPoints[t],
	   newp = ComposedChar[{}], oldp, cstr, posnr=1, go = True },
	If[ info[[1,n]]===Null, info[[1,n]]={} ];
        If[ (oldp=PropagatorLabelPosition/.info[[1,n]]) ===
	    PropagatorLabelPosition,
	   oldp = ComposedChar[{}] ];
	While[ go,
	      cstr = " ";
	      While[ FreeQ[ {"x","q","a","","y"},
		     cstr = InputString["Change Position of depth "<>
		            ToString[posnr]<>PosNrString[posnr]<>
			    " (q=quit, x=exit, a=auto) ? "] ] ] ; 
	      Which[  cstr === "q", 
		    go = False,
	              cstr === "a",
	            AppendTo[ newp[[1]], Null ]; posnr++ ,
	              cstr === "x",
	            If[ Length[newp[[1]]] > 0 ,
		       Print["... setting LabelPosition to ",newp];
	               SetFeature[t, PropagatorLabelPosition->newp, n] ,
	               SetFeature[ t, PropagatorLabelPosition -> Automatic, n] 
		       ];
	            go = False, 
	              True,
		    newp = ReadLabelPos[ oldp, newp, posnr ]; posnr++
	           ];
              If[ posnr===5,
	         Print["... setting LabelPosition to ",newp];
	         SetFeature[t, PropagatorLabelPosition->newp, n];
	         go = False
	        ]
	    ]
       ];
               
(* for the mixing-propagators (just a "doubled" TSSetLabelPos)
*)
TSSetDLabelPos[ t_Topology ] :=
  Block[ { n = TSReadProp[Length[t]], info = Global`GraphPoints[t],
	   newp = {ComposedChar[{}],ComposedChar[{}]}, 
	   oldp, cstr, posnr, go },
	If[ info[[1,n]]===Null, info[[1,n]]={} ];
        If[ (oldp=PropagatorDLabelPosition/.info[[1,n]]) ===
	    PropagatorDLabelPosition,
	   oldp = {ComposedChar[{}],ComposedChar[{}]} ];
     Do[
	Print["setting label #",i];
	posnr = 1;
	go = True;
	While[ go,
	      cstr = " ";
	      While[ FreeQ[ {"x","q","a","","y"},
		     cstr = InputString["Change Position of depth "<>
		            ToString[posnr]<>PosNrString[posnr]<>
			    " (q=quit, x=exit, a=auto) ? "] ] ] ; 
	      Which[  cstr === "q", 
		    go = False,
	              cstr === "a",
	            AppendTo[ newp[[i,1]], Null ]; posnr++ ,
	              cstr === "x",
	            If[ i===2 ,
		       newp = newp/.ComposedChar[{}]->Automatic;
		       Print["... setting LabelPosition to ",newp];
	               SetFeature[t, PropagatorDLabelPosition->newp, n] ,
		       ];
	            go = False, 
	              True,
		    newp[[i]] = 
		     ReadLabelPos[ oldp[[i]], newp[[i]], posnr ]; posnr++
	           ];
              If[ posnr===5,
		 If[ i==2,
		    newp = newp/.ComposedChar[{}]->Automatic;
	            Print["... setting LabelPosition to ",newp];
	            SetFeature[t, PropagatorDLabelPosition->newp, n]
		   ];
	         go = False
	        ]
	    ],
	{i, 2}
	]
       ];
               
TSSetGraphLabelPos[ t_Topology ] :=
  Block[ { info = Global`GraphPoints[t],
	   newp = ComposedChar[{}], oldp, cstr, posnr=1, go = True },
        If[ (oldp=GraphLabelPosition/.info[[3]]) ===
	    GraphLabelPosition,
	   oldp = ComposedChar[{}],
	   If[ MatchQ[ oldp, point ], 
	       oldp = ComposedChar[{oldp}] ]
	  ];
	While[ go,
	      cstr = " ";
	      While[ FreeQ[ {"x","q","a","","y"},
		     cstr = InputString["Change Position of depth "<>
		            ToString[posnr]<>PosNrString[posnr]<>
			    " (q=quit, x=exit, a=auto) ? "] ] ] ; 
	      Which[  cstr === "q", 
		    go = False,
	              cstr === "a",
	            AppendTo[ newp[[1]], Null ]; posnr++ ,
	              cstr === "x",
	            If[ Length[newp[[1]]] > 0 ,
		       Print["... setting GraphLabelPosition to ",newp];
	               SetTFeature[t, GraphLabelPosition->newp ] ,
	               SetTFeature[ t, GraphLabelPosition -> Automatic ] 
		       ];
	            go = False, 
	              True,
		    newp = ReadLabelPos[ oldp, newp, posnr ]; posnr++
	           ];
              If[ posnr===5,
	         Print["... setting GraphLabelPosition to ",newp];
	         SetFeature[t, GraphLabelPosition->newp ];
	         go = False
	        ]
	    ]
       ];

(* utility function for TSSetLabelPos
*)
ReadLabelPos[ o_ComposedChar, n_ComposedChar, m_Integer ] :=
  Block[ { oldx, oldy, newx, newy },
	If[ Length[o[[1]]] < m,
	   {oldx, oldy} = {"auto", "auto"},
	   {oldx, oldy} = o[[1,m]]		];
	While[ !NumberQ[ newx=Input[PosNrString[m]<>"  x="<>
				    ToString[oldx]<>" -> x="] ] ];
	While[ !NumberQ[ newy=Input[PosNrString[m]<>"  y="<>
				    ToString[oldy]<>" -> y="] ] ];
	Return[ ComposedChar[Append[n[[1]], {newx, newy}]] ];
];	

PosNrString[ 1 ] = " (label)";
PosNrString[ 2 ] = " (subscript-shift)";
PosNrString[ 3 ] = " (superscript-shift)";
PosNrString[ 4 ] = " (`tilde'-shift)";

(* choose endpoints 
*)
NewEndpoints[ t_Symbol, new_List ] := 
   NewEndpoints[ {t,t}, new ];
NewEndpoints[ {p_,q_}, {n_,Hold} ] := 
   CheckEndpoints[ {n,q}  ];
NewEndpoints[ {p_,q_}, {Hold,n_} ] := 
   CheckEndpoints[ {p,n}  ];
CheckEndpoints[ { a_, a_ } ] := a;
CheckEndpoints[ a_List ] :=a;

SetEndpoints[ top_Topology, v:Vertex[_,___][_], 
	      n_Integer, type_ ] :=
  Block[ { prop = top[[n]], call = CallFeature[top,PropagatorEndpoints,n] },
        If[ call === False, call = {None, None} ];
	If[ prop[[1]] === v, 
	    SetFeature[ top, PropagatorEndpoints->
			NewEndpoints[call,{type,Hold}], n ] ];
	(* "call" again for the case of Tadpoles *)
        call = CallFeature[top, PropagatorEndpoints, n] ;
        If[ call === False, call = {None, None} ];
	If[ prop[[2]] === v, 
	    SetFeature[ top, PropagatorEndpoints->
			NewEndpoints[call,{Hold,type}], n ] ];
      ] /; !FreeQ[ top[[n]], v ];

TSShapeEndpoints[ edittop_ ] :=
  Block[ { vert, input },
	While[ FreeQ[ {"y","n"},
	              input = 
		      InputString["Standard ? (y/n) "] ] ];
	If[ input == "y",
	    SetStandardEndpoints[ edittop ];
	    Return[] ];
        vert = InputVertex[edittop];
	While[ FreeQ[ {"v","c", "C", "n"},
	      input = 
	      InputString[ToString[vert]<>" Type ? (v, c, C or n) = "] ] ];
	Which[ input == "v", input = Vertex,
	       input == "c", input = CounterTerm,
	       input == "C", 
                While[ FreeQ[{"1","2","3"},
                         input = InputString[" Order ? (1, 2 or 3) = "] ] ];
               input = CounterTerm[ToExpression[input]],
	       input == "n", input = None ];
        Do[ SetEndpoints[ edittop, vert, i, input ], 
	    {i,1,Length[edittop]} ]
       ];

SetStandardEndpoints[ t_Topology ] :=
  Block[ { vend = Vertices[t], vlow, vhigher },
	vend = 
          Select[ vend, !MatchQ[#, Vertex[1][_]|Vertex[1,0][_]]& ];
        vlow = 
	 Select[ vend, (MatchQ[#, Vertex[_][_]|Vertex[_,0][_] ])& ];
        vhigher = 
	 Select[ vend, (MatchQ[#, Vertex[_,_Integer?Positive][_] ])& ];
	Do[ SetEndpoints[ t, vlow[[i]], j, Vertex ] ,
	    {i, 1, Length[vlow]}, {j, 1, Length[t]}  ];
	Do[ SetEndpoints[ t, vhigher[[i]], j, CounterTerm ],
	    {i, 1, Length[vhigher]}, {j, 1, Length[t]}  ];
      ];

(* append the dummy-labels: we need it to have the propagator numbers on
   the screen. Nevertheless it is rather difficult to set the positions of
   the labels nice.
*)
TSAppend[ t_Topology, l_ ] := 
    Topology@@ Table[ Append[ t[[i]], l[i] ], {i,1,Length[t]} ];

TheLabel[StLab[i_]] := ComposedChar[ {ToString[i], "i", "j", "-"} ];
TheLabel[SiLab[i_]] := ComposedChar[ {ToString[i], "i", "j", "-"} ];
TheLabel[CyLab[i_]] := ComposedChar[ {ToString[i], "i", "j", "-"} ];

PropagatorType[StLab[_]] = Straight;
PropagatorType[SiLab[_]] = Sine;
PropagatorType[CyLab[_]] = Cycles;

PropagatorArrow[x:(StLab[_]|SiLab[_]|CyLab[_])] = None;

AntiParticle[ StLab[i_] ] := StLab[i];
AntiParticle[ SiLab[i_] ] := SiLab[i];
AntiParticle[ CyLab[i_] ] := SyLab[i];

(* choose first coordinates: this substitutes our randomization of points. 
*)
TSSetFirstGraphPoints[ t_Topology ] := 
Block[{ matrix, firstrow, lastrow, newrow, newprops, 
        tadp = Cases[ List@@t, Propagator[_][a_,a_] -> a ],
	topo = Select[ List@@t, !MatchQ[ #, Propagator[_][a_,a_] ]& ],
	info = Global`GraphPoints[t]/.Null->{}, temptop, stop=False },
(*
DePrint["tadp: ", tadp];
DePrint["topo: ", topo];
*)
      If[ FreeQ[ topo, Incoming ],
	  If[ Length[ newrow=Select[topo, !FreeQ[#, External]&] ] > 3,
	      firstrow = Table[ Vertex[1][i], {i,2} ] ;
	      lastrow = Table[ Vertex[1][i], {i, 3, Length[newrow]} ],
	      If[ Length[newrow] =!= 0,
	          firstrow = {Vertex[1][1]};
	          lastrow = Table[Vertex[1][i], {i, 2, Length[newrow]} ],
		  firstrow={};
		  lastrow={}
		]
	    ],
	  firstrow = 
	    Table[ Vertex[1][i], 
		   {i,1, Length[Cases[topo, Propagator[Incoming][__]]]} 
		 ];
	  lastrow = 
	    Table[ Vertex[1][i], {i,Length[firstrow]+1, 
		   Length[Cases[topo, Propagator[Outgoing][__]]]+
		    Length[firstrow] } 
		 ]
	];
(* if we have a 0-leg topology we just pick two vertices randomly: *)
      If[ firstrow === {},
	  temptop = Union[ Flatten[ ( List@@# )& /@ topo ] ];
          If[ Length[temptop]==0, (* nothing left but tadpoles *)
              temptop = Union[ Flatten[ tadp ] ]
            ];
	  Which[ Length[temptop] == 1,
	         Global`GraphPoints[t] = { Table[Null,{Length[t]}],
					   {temptop[[1]]->{10,10}},{} };
		 stop=True,
		 Length[temptop] == 2,
		 Global`GraphPoints[t] = { Table[Null,{Length[t]}],{
		  temptop[[1]]->{5,10}, temptop[[2]]->{15,10}}, {} };
		 stop=True,
		 Length[temptop]>2,
		 firstrow = {First[temptop]};
		 lastrow = {Last[temptop]}
		]
	];
(*
DePrint["firstrow = ",firstrow];
DePrint["lastrow = ",lastrow];
*)
      If[ stop, Return[] ];
(* knowing in/out points we can replace the Propagators by Lists: *)
      topo = ( List@@# )& /@ topo;
      matrix =  { firstrow };
      While[ topo =!= {},
(*
DePrint["matrix 0: ", matrix];
*)
             (* lines to the left: *)
	     newrow = FindProps[ Last[matrix], topo ];
(*
DePrint["newrow 0: ", newrow];
DePrint["FP = ", FindProps[ lastrow, newrow ] ];
*)
             (* if it's not only lines to the last row *)
	     If[ FindProps[ lastrow, newrow ] =!= newrow,
                (* then: don't use lines to last row *)
		 newrow = Complement[ newrow, FindProps[ lastrow, newrow ] ],
                (* else: *) 
                 (* if that's all: lines to the left == lines to the right *)
                 If[ newrow === FindProps[ lastrow, topo ],
                    (* there's only the last row left *)
		     newrow = lastrow,
                    (* else: put anything into last row *)
                     newrow = Join[ lastrow, FindProps[ lastrow, topo ] ]
                   ];
		 topo = {}
	       ];
	     topo = Complement[ topo, newrow ];
	     newrow = Complement[ Union[Flatten[newrow]], Last[matrix] ];
	     AppendTo[ matrix, newrow ]
	   ];
(*
DePrint["matrix:", matrix];
*)
      matrix = matrix//.{a___,{},b___}:>{a,b};
(* put tadpole vertex one row back *)
      matrix = Fold[ ShiftLeft, matrix, tadp ];
      If[ info =!= HighEnergyPhysics`FeynArts`$Undefined,
(* HERE: if CT-topology *)
	  If[ InputString["Overwrite previous GraphPoints definition ? [n] "
			 ] === "y" ,
	      Global`GraphPoints[t] = { Table[ Null, {Length[t]} ],
                                        ChooseFirstPoints[matrix] ,
					{} }
	    ],
	  Global`GraphPoints[t] = { Table[ Null, {Length[t]} ],
                                     ChooseFirstPoints[matrix] ,
				     {} }
	];
     ];

FindProps[ row_List, top_List ] := 
    Flatten[ Function[ z, Select[ top, !FreeQ[ #, z ]& ] ] /@ row , 1 ];

ChooseFirstPoints[ mat_List ] :=
Block[ { rows = Length[mat], lines, xinc, yinc, ret = {} },
      xinc = 20 / (rows-1);
      Do[
         lines = Length[mat[[i]]];
	 yinc = 20 / (lines+1);
         Do[ AppendTo[ ret, mat[[i,j]] -> 
		      { 0 + Round[xinc*(i-1)], 20 - Round[yinc*j] } ],
	     {j,lines}
	   ],
         {i, rows}
	];
       Return[ ret ];
      ];

ShiftLeft[ m_List, x_ ] := m /. { a__List, {b___, x, c___ }, d__List } :>
				Join[ Drop[{a},-1], {Append[Last[{a}],x]},
				      {{b,c}}, {d} ];

(* print information 
*)
TSPrintPoints[ t_Topology ] :=
Block[{ info = Global`GraphPoints[t]/.Null->{}, pstring },
      If[ info === HighEnergyPhysics`FeynArts`$Undefined,
	  Print["Topology not initialized."];
	  Return[]
	];
      Do[
	 pstring = ToString[i] <> ")  " <> ToString[ t[[i,1]] ] <> " (" <> 
		   ToString[ t[[i,1]]/.info[[2]] ] <> ") --> " <>
		   ToString[ t[[i,2]] ] <> "(" <>
		   ToString[ t[[i,2]]/.info[[2]] ] <> ") ";
	 If[ (Propagator3rdPoint/.info[[1,i]]) =!= Propagator3rdPoint,
	    pstring = pstring <> " center : " <>
		      ToString[Propagator3rdPoint/.info[[1,i]]] ];
	 If[ (PropagatorHeight/.info[[1,i]]) =!= PropagatorHeight,
	    pstring = pstring<>" height : "<>
		      ToString[PropagatorHeight/.info[[1,i]]] ] ;
         Print[pstring],
	{i, Length[t]}
       ];
     ];
     
TSLongPrintPoints[ t_Topology ] :=
Block[ { info = Global`GraphPoints[t], pstring },
      If[ info === HighEnergyPhysics`FeynArts`$Undefined,
	  Print["Topology not initialized."];
	  Return[]
	];
      Do[
	 Print[ ToString[i] <> ")  " <> ToString[ t[[i,1]] ] <> " (" <> 
	        ToString[ t[[i,1]]/.info[[2]] ] <> ") --> " <>
	        ToString[ t[[i,2]] ] <> "(" <>
		ToString[ t[[i,2]]/.info[[2]] ] <> ") " ];
	 Do[ Print["\t", info[[1,i,j]] ], {j, Length[info[[1,i]]]} ],
	 {i, Length[t]}
	];
      Do[ Print["-  ",info[[3,i]]] , {i,Length[info[[3]]]} ];
     ];
	 

(* choose center of propagator 
*)
TSCenterChoice[ t_Topology ] :=
Block[{ n = TSReadProp[Length[t]], info = Global`GraphPoints[t],
	cenx, ceny },
       While[ !NumberQ[ cenx=Input["Center #"<>ToString[n]<>" : x = "]]];
       While[ !NumberQ[ ceny=Input["Center #"<>ToString[n]<>" : y = "]]];
       SetFeature[t, Propagator3rdPoint->{cenx, ceny}, n ];
     ];

(* shift the whole graph up or down 
*)
TSGraphShift[ t_Topology ] :=
Block[{ info = Global`GraphPoints[t], shift },
      While[ !NumberQ[ shift = Input["Shift the whole graph by : "] ] ];
      info[[2]] = info[[2]] /. {x_?numberQ, y_?numberQ} :> {x, y+shift};
      info[[1]] = info[[1]] /. 
       (Propagator3rdPoint->{x_,y_}) :> (Propagator3rdPoint->{x,y+shift});
      Set[ Global`GraphPoints[t], info ];
     ];

(* file handling for Shape : 
*)
IsFile[ f_String ] :=
Block[ { path, info },
      path = StringJoin[#,"/"<>f ]& /@ $Path;
      info = Select[ FileInformation/@path, (#=!={})& ];
      If[ Length[info] === 0,
	  Return[ False ],
	  Return[ File/.Select[ info, ((FileType/.#)===File)& ][[1]] ]
	];
     ];

IsDirectory[ dir_String ] :=
Block[ { path, info },
      path = StringJoin[#,"/"<>dir]& /@ $Path;
      info = Select[ FileInformation/@path, (#=!={})& ];
      If[ Length[info] === 0,
	  Return[ False ],
	  Return[ File/.Select[ info, ((FileType/.#)===Directory)& ][[1]] ]
	];
     ];

TSFileHandling[ bt_Topology, name_String ] :=
Block[ { thedir, thefile, therealdir, therealfile, input },
      thedir = 
       StringDrop[ ContextToFilename[ name ], -2 ] <> $PathnameSeparator;
      thefile = ContextToFilename[ name<>GraphTypeFunction[bt]<>"`" ];
      While[ FreeQ[ {"y","n",""},
              input = 
	       InputString["Write to folder "<>thedir<>" ? (y/n) "] ] 
	   ];
      (* try to save: *)
      If[ !( input == "n"),
	  If[ (therealfile=IsFile[ thefile ]) =!= False,
              Print["Overwrite file ",therealfile];
	      DeleteFile[ therealfile ];
	      Save[ therealfile, Global`GraphPoints ];
	      Return[],
	      If[ (therealdir = IsDirectory[ thedir ]) =!= False,
                  therealfile = therealdir<>GraphTypeFunction[bt]<>".m";
                  Print["Create file ", therealfile];
	          Save[ therealfile, Global`GraphPoints ];
		  Return[],
		  Print["Directory ", thedir ," not found!"];
		];
	    ];
        ];
      While[ FreeQ[ {"x",""},
              input = InputString["New $TopologyDataDir (x=exit): "] ]
	   ];
      Which[ input=="x",
	     Return[],
	     input=="",
	     TSFileHandling[ t, name ],
	     True,
	     $TopologyDataDir = input;
             TSFileHandling[t, input];
	   ];
      Print["Error in procedure TSFileHandling!"];
     ];

(* the `help!'-message 
*)

PrintShapeHelp[] :=
 (
  Print["the following commands are available :"];
  Print["  c  (center)   choose coordinates of center of line"];
  Print["  d  (double)   set double labels"];
  Print["  e  (end)      set form of endpoints"];
  Print["  f  (file)     save the GraphPoints-functions"];
  Print["  h  (height)   choose curvature of line"];
  Print["  l  (label)    set propagator label position(s)"];
  Print["  L  (label)    set graph label position(s)"];
  Print["  p  (print)    print the topology (propagators+centers)"];
  Print["  P  (print)    print complete GraphPoints-information"];
  Print["  a  (auto)     autoshape topology"];
  Print["  s  (show)     display the current topology with grid"];
  Print["  t  (toggle)   info messages on/off"];
  Print["  u  (up)       shift the complete graph in y-direction"];
  Print["  v  (vertex)   shift a field point"];
  Print["  x  (exit)     leave Shape"];
  Print["  z  (zap)      set amplitude, periods and phases (wizards only)"];
  Print["  ?  (help)     this message"]
 );

(* sub menu : set amplitude, phase, and periods 
*)

TSSubMenu[ t_Topology ] :=
Block[ { command, subcom, info = Global`GraphPoints[t] },
     command = "?";
     While[ command =!= "x",
       Which[
	     command == "s",    
             While[ FreeQ[ {"c", "s", "x"}, subcom = 
		   InputString["Sine, Cycles or exit ? (c, s or x) :"]]];
             If[ subcom == "c",
                 Show[ TopologyGraphics[ TSAppend[ t, CyLab ], 
			               ShowGrid->True,
			               AspectRatio->1  ]]];
             If[ subcom == "s",
                 Show[ TopologyGraphics[ TSAppend[ t, SiLab ], 
			               ShowGrid->True,
			               AspectRatio->1  ]]],
	     command == "c",
	     subcom = "?";
	     While[ subcom =!= "x",
	        Which[  subcom == "a" , SetAmplitude[ t ] ,
	                subcom == "p" , SetPeriods[ t ] ,
	                subcom == "f" , SetPhase[ t ] ,
	                subcom == "?" ,
		         Print["You can set the"];
		         Print[" - amplitude (\"a\")"];
		         Print[" - periods (\"p\")"];
		         Print[" - phase (\"f\")"];
		         Print[" - go back (\"x\")"] ];
	        While[FreeQ[{"a","p","f","x","?"}, subcom =
		                  InputString["TS > > > "]]];
		],
	     command == "?",
	     Print["You can "];
	     Print[" - change parameters (\"c\")"];
	     Print[" - draw the graph (\"s\")"];
	     Print[" - go back (\"x\")"]
            ];
      While[FreeQ[{"s","c","x","?"},command=InputString[ "TS > > "]]]
      ];
    ];

(* special settings . no check of input so be careful! 
*)
SetAmplitude[ t_Topology ] :=
Block[ { n = TSReadProp[ Length[t] ], info = Global`GraphPoints[t],
	 oldam, newam, oldli },
      oldli = If[ info[[1,n]] === Null, {}, info[[1,n]] ];
      oldam = PropagatorAmplitude/.oldli/.Options[PropagatorGraphics];
      While[ !NumberQ[ newam = Input[
	  "Change amplitude from "<>ToString[oldam]<>" to (0=$Default): "]]];
      If[ newam == 0, newam = $Default ];
      SetFeature[ t, PropagatorAmplitude ->newam, n ];
];

SetPeriods[ t_Topology ] :=
Block[ { n = TSReadProp[ Length[t] ], info = Global`GraphPoints[t],
	 oldpe, newpe, oldli },
      oldli = If[ info[[1,n]] === Null, {}, info[[1,n]] ];
      oldpe = PropagatorPeriods/.oldli/.Options[PropagatorGraphics];
      While[ !NumberQ[ newpe = Input[
	     "Change periods from "<>ToString[oldpe]<>" to (0=$Default): "]]];
      If[ newpe == 0, newpe = $Default ];
      SetFeature[ t, PropagatorPeriods ->newpe, n ];
];

SetPhase[ t_Topology ] :=
Block[ { n = TSReadProp[ Length[t] ], info = Global`GraphPoints[t],
	 oldph, newph, oldli },
      oldli = If[ info[[1,n]] === Null, {}, info[[1,n]] ];
      oldph = PropagatorPhase/.oldli/.Options[PropagatorGraphics];
      While[ !NumberQ[ newph = Input[
	     "Change phase from "<>ToString[oldph]<>" to (0=$Default): "]]];
      If[ newph == 0, newph = $Default ];
      SetFeature[ t, PropagatorPhase ->newph, n ];
];




End[] (* HighEnergyPhysics`FeynArts`Graphics` *)

(**)
