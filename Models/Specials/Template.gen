
(* :Title: Template.gen *) 

(* :Authors:  *) 

(* :Summary: Generic model template for FeynArts` *)

(* :Context: HighEnergyPhysics`FeynArts` *)

(* :Description:
	This model file defines the general analytical propagators and
	couplings and some additional functions that work on the generic
	level of the generation process.
	
*)

(* This line indicates the type of generic model that is loaded (should
   be the basename of this file).
   Only one type of Feynman rules - corresponding to a certain generic
   model file like this one - can be active at a time.
*)
$FeynmanRulesType = "Template";

(* Kinematic indices are `transported' along a propagator line.
   KinematicIndices[X] = {Name} means, that the generic field X will carry
   an index Index[Name, i] along the line:  
   X[ n, {m..}, p, {Index[Name, i]} -> {Index[Name, i+1]} ].
   This four lines define the names of the kinematic indices.
*)
KinematicIndices[F] = {};
KinematicIndices[V] = {Lorentz};
KinematicIndices[S] = {};
KinematicIndices[U] = {};

(* Appearance of an index defines how this index appears in the Feynman
   diagrams. Usually one uses greek or roman letters. These letters are
   defined via one of the functions Alph, UCAlph, Greek, UCGreek which
   take an integer number as argument (UC=UpperCase).
   In the example we start with the 10th greek letter (mu), i.e:
   Index[Lorentz, 1] -> mu, Index[Lorentz, 2] -> nu etc.
*)
Appearance[ Index[Lorentz, i_Integer ] ] := Greek[i+10];

(* Remarks about generic masses and mixing fields:
	If - e.g. in mixing cases - several mass parameters are needed in 
one propagator then the mass of the corresponding particle can be a list of
parameters: Mass[ V[5] ] := {MW1,MW2}. In the corresponding generic file 
the propagators contain these parameters in the form Mass[ V[i]][[1]] etc.
	SV is a mixed scalar vector field. It is a scalar running from 
vertex 1 changing into a vector going into vertex 2. Reversing the vertex 
points means that now its antiparticle is running as a vector with opposite 
charge from new vertex 1 changing to a scalar running into new vertex 2.
	VS is a mixed scalar vector field. It is a vector running from 
vertex 1 changing into a scalar going into vertex 2. Reversing the vertex 
points means that now its antiparticle is running as a scalar with opposite 
charge from new vertex 1 changing to a vector running into new vertex 2.
(This means that for neutral fields only SV is needed, for charged SV and VS!)
*)

(* --------------------------------------------------------------------- *)
(* Definition of the generic propagators.
   In this list, we give definitions for the function
          
               AnalyticalPropagator[ type ][ field ]

   by using the Mathematica symbol "Equal" (==). With `type' we distinguish
   External and Internal propagators. The definitions will internally be
   converted to Mathematica functio definitions. If the analytical
   expression for the propagator contains non-commuting objects (as in the
   case of Dirac fermions) these objects have to be surrounded by the 
   symbol NonCommutative (see below). It is also possible to distinguish
   SelfConjugate and non-SelfConjugate fields (see `general fermion
   propagator').
   The fields have the form    s*X[ i, mom ]                     (1)
                         or    s*X[ i, mom, {ki,..} ]            (2)
                         or    s*X[ i, mom, {ki,..}->{kj,..} ]   (3)
   general: s serves as dummy argument for the sign of the field (anti-
              particles for non-selfconjugate fields are denoted by negative
              signs)
            X is a generic field type (one of F, S, U, V)
            i denotes the indices of the field except kinematic indices. i
              is of the form " i1, {i2, i3, ..} " where i1 gives the class
              index and the sum contains the indeces specific for this 
              class (the i1'th class of X-fields)
            mom is the momentum carried by that field.
   (1):  is a field that carries no kinematic indices (with the definitions
         above: F, S, U)
   (2):  is an External field carrying kinematic indices (this corresponds
         to an external vector boson field here where {ki,...} = {Lorentz}
   (3):  is an internal field carrying kinematic indices (in the above
         example: {ki,..}->{kj,..} = {Lorentz[1]}->{Lorentz[2]}. In the SM
         this generates a metric tensor for the propagator g[mu,nu] =
         MetricTensor[Lorentz[1],Lorentz[2]].

*)

GenericPropagators[ "Template" ] =
{

(* general fermion propagator: *)

AnalyticalPropagator[External][ s F[i, mom] ] == 
  If[ SelfConjugate[F[i]],
	  NonCommutative[ 
	    MajoranaSpinor[ mom, Mass[ F[i] ], Sequence @@ Drop[{i},1] ] ],
	  NonCommutative[ 
	    DiracSpinor[ mom, Mass[ F[i] ], Sequence @@ Drop[{i},1] ] ] ], 

AnalyticalPropagator[Internal][ s F[i,mom] ] == 
          NonCommutative[ DiracSlash[ mom ] + Mass[F[i]] ]  
	       I PropagatorDenominator[ mom , Mass[F[i]] ], 

(* general vector boson propagator: *)

AnalyticalPropagator[External][ s V[i, mom,{li2}] ] == 
	  PolarizationVector[ V[i], mom, li2 ], 

AnalyticalPropagator[Internal][ s V[i,mom,{li1}->{li2}] ] == 
	  I PropagatorDenominator[ mom , Mass[V[i]] ]
	       ( - MetricTensor[li1, li2] ),

(* general mixing scalar-vector propagator: *)

AnalyticalPropagator[Internal][ s SV[i,mom,{li1}] ] == 
	  I Mass[SV[i]] * PropagatorDenominator[ mom , Mass[SV[i]] ]
	       ( FourVector[ mom, li1 ] ),

(* general mixing vector-scalar propagator: *)

AnalyticalPropagator[Internal][ s VS[i,mom,{li1}] ] == 
	  I Mass[VS[i]] * PropagatorDenominator[ mom , Mass[VS[i]] ]
	       ( FourVector[ mom, li1 ] ), 

(* general scalar particle propagator: *)

AnalyticalPropagator[External][ s S[i,mom] ] == 1, 
AnalyticalPropagator[Internal][ s S[i,mom] ] == 
          I PropagatorDenominator[ mom , Mass[S[i]] ],

(* general Fadeev-Popov-ghost propagator: *)

AnalyticalPropagator[Internal][ s U[i,mom] ] == 
          I PropagatorDenominator[ mom , Mass[U[i]] ]

};
(* --------------------------------------------------------------------- *)



(* --------------------------------------------------------------------- *)
(* Definition of the generic couplings.
   In a similar way like for the propagtors we define now the couplings
   of the fields:

	AnalyticalCoupling[ field1, field2, .. ] == G . {k1, k2, ..}

   field1, field2, .. are field specification like for the propagator
       definitions.
   the lhs is a vector product of the generic coupling vector G and the
       kinematic vector {k1, k2, ...}
    G has the form G[ sym ][ fi1, fi2, .. ] where sym denotes the
       permutation symmetry of the kinematical vector (+1/-1 for even or odd
       symmetry). The fields of the generic coupling vector (fi1, fi2, ..)
       the fields of the rhs but WITHOUT kinematic indices or momenta.
       i.e.  field = s X[i, mom, {i}]  -> fi = s X[i]
    {k1, k2, ...} is the kinematical vector and contains a number of entries
       that contain kinematic indices and momenta.
    
    The separation of the class indeces ("i") on one hand and the momenta 
    ("mom") and kinematical indices ("{ki,...}") on the other hand is the
    GENERIC CONCEPT.

    Remark: for couplings that are independend of momenta or kinematical
    indeces it is, of course, possible to omit the kinematical vector.
    The kinematical vector can be one-dimensional as well.
*)
                     

GenericCouplings[ "Template" ] =
{

(* 2-vertices *)

AnalyticalCoupling[ s1 F[i,mom1], s2 F[j,mom2] ] ==
   G[1][ s1 F[i], s2 F[j] ] .
          { NonCommutative[ DiracSlash[mom1], ChiralityProjector[-1] ],
            NonCommutative[ DiracSlash[mom1], ChiralityProjector[+1] ],
            NonCommutative[ ChiralityProjector[-1] ],
            NonCommutative[ ChiralityProjector[+1] ] },

AnalyticalCoupling[ s1 S[i,mom1], s2 S[j,mom2] ] ==
   G[1][ s1 S[i], s2 S[j] ] .  { mom1 ^ 2, 1 },

AnalyticalCoupling[ s1 V[i,mom1,{li1}], s2 V[j,mom2,{li2}] ] ==
   G[1][ s1 V[i], s2 V[j] ] . { - MetricTensor[li1,li2] * mom1 ^ 2,
                             - MetricTensor[li1,li2] * 1         },

(* 3-vertices *)

(* 1 FFS-coupling:
*)
AnalyticalCoupling[ s1 F[i,mom1], s2 F[j,mom2], 
			s3 S[k,mom3] ] ==
   G[1][ s1 F[i], s2 F[j], s3 S[k] ] . 
       { NonCommutative[ ChiralityProjector[-1] ],  
         NonCommutative[ ChiralityProjector[+1] ] },

(* 2 FFV-coupling:
*)
AnalyticalCoupling[ s1 F[i,mom1], s2 F[j,mom2], 
		    s3 V[k,mom3,{li3}] ] ==
   G[-1][ s1 F[i], s2 F[j], s3 V[k] ] . 
		  { NonCommutative[DiracMatrix[li3], ChiralityProjector[-1]], 
                    NonCommutative[DiracMatrix[li3], ChiralityProjector[+1]] }, 
 
(* 3 SUU-coupling:
*)
AnalyticalCoupling[ s1 S[i,mom1], s2 U[j,mom2], 
			s3 U[k,mom3] ] == 
   G[1][ s1 S[i], s2 U[j], s3 U[k] ], 

(* 4 UUV-coupling:
*)
AnalyticalCoupling[ s1 U[i,mom1], s2 U[j,mom2], 
		    s3 V[k,mom3,{li3}] ]   == 
   G[1][ s1 U[i], s2 U[j], s3 V[k] ] . 
	   { FourVector[ mom1, li3], FourVector[ mom2, li3] },

(* 5 SSS-coupling:
*)
AnalyticalCoupling[ s1 S[i,mom1], s2 S[j,mom2], 
                        s3 S[k,mom3] ] ==
   G[1][ s1 S[i], s2 S[j], s3 S[k] ], 

(* 6 SSV-coupling:
*)
AnalyticalCoupling[ s1 S[i,mom1], s2 S[j,mom2], 
		    s3 V[k,mom3,{li3}] ]   == 
   G[-1][ s1 S[i], s2 S[j], s3 V[k] ] . { FourVector[ mom1 - mom2 , li3 ] },

(* 7 SVV-coupling:
*)
AnalyticalCoupling[ s1 S[i,mom1], s2 V[j,mom2,{li2}], 
		    s3 V[k,mom3,{li3}] ]  == 
   G[1][ s1 S[i], s2 V[j], s3 V[k] ] MetricTensor[ li2,li3 ],

(* 8 VVV-coupling:
*)
AnalyticalCoupling[ s1 V[i,mom1,{li1}], s2 V[j,mom2,{li2}], 
		    s3 V[k,mom3,{li3}] ]  ==
   G[-1][ s1 V[i], s2 V[j], s3 V[k] ] . 
	     {  ( MetricTensor[ li1,li2 ] FourVector[ mom2 - mom1, li3 ] +
                  MetricTensor[ li2,li3 ] FourVector[ mom3 - mom2, li1 ] +
                  MetricTensor[ li3,li1 ] FourVector[ mom1 - mom3, li2 ] ) },

(* 4-vertices *)

(* 9 SSSS-coupling:
*)

AnalyticalCoupling[ s1 S[i,mom1], s2 S[j,mom2], 
		    s3 S[k,mom3], s4 S[l,mom4] ]  == 
   G[1][ s1 S[i], s2 S[j], s3 S[k], s4 S[l] ],

(* 10 SSVV-coupling:
*)
AnalyticalCoupling[ s1 S[i,mom1], s2 S[j,mom2], 
		    s3 V[k,mom3,{li3}], s4 V[l,mom4,{li4}] ]  == 
   G[1][ s1 S[i], s2 S[j], s3 V[k], s4 V[l] ] MetricTensor[ li3,li4 ],

(* 11 VVVV-coupling:
*)
AnalyticalCoupling[ s1 V[i,mom1,{li1}], s2 V[j,mom2,{li2}], 
		    s3 V[k,mom3,{li3}], s4 V[l,mom4,{li4}] ]  == 
   G[1][ s1 V[i], s2 V[j], s3 V[k], s4 V[l] ] . 
		    { MetricTensor[ li1,li2 ] MetricTensor[ li3,li4 ],
		      MetricTensor[ li1,li3 ] MetricTensor[ li2,li4 ],
		      MetricTensor[ li1,li4 ] MetricTensor[ li3,li2 ] }


};

(* FermionFlipRules: for a certain mapping of Fermion fields in a coupling
   we have to know which operations to perform.
   Usually only two fermions are involved in a coupling. Since the fermions
   are always sorted to the beginning of the coupling, one only has to 
   define the behavior of these couplng under the exchange of those two
   fermions.
   For more complicated couplings, additional FermionFlipRules (for more
   complicated patterns) can be given.
*)
FermionFlipRule[ 1->2, 2->1, ___ ] =
{
  ChiralityProjector[1]->ChiralityProjector[-1],
  ChiralityProjector[-1]->ChiralityProjector[1]
};

(* TruncationRules: rule for omitting the wave functions of external
   Propagators defined in this file.
   These rules are applied when calling CreateFeynAmp with the option
   Truncated->True. Usually they just replace parts of the external
   propagators (or the complete propagators) by 1.
*)
TruncationRules = 
  {
   PolarizationVector[__] 	-> 1 ,
   DiracSpinor[__] 		-> 1 ,
   MajoranaSpinor[__] 		-> 1 
  };

(* LastGenericRules: the very last rules that are applied to an amplitude
   before it is returned by CreateFeynAmp.
*)
LastGenericRules = 
  {
   (* relicts of the truncation of spinors: *)
   Dot[ 1, line__, 1 ] :> Dot[ line ],
   Dot[ 1, 1 ] :> 1,
   (* Outgoing vector bosons: *)
   PolarizationVector[ p_, k:FourMomentum[ Outgoing, i_Integer ], li_ ] :> 
    Conjugate[ PolarizationVector[ p, k, li ] ]
  };

(**)
